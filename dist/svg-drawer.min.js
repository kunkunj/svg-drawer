(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["svg-drawer"] = {}));
})(this, (function (exports) { 'use strict';

  const DEFAULT_SIZE = 500;
  const DEFAULT_CACHE = 5;
  const DEFAULT_MULTIPLE = 2;
  const DEFAULT_SVGNS = "http://www.w3.org/2000/svg";
  const SVG_PATH_DIRECTION = {
      L: "L",
      M: "M",
      Q: "Q",
  };
  var SVG_TYPE;
  (function (SVG_TYPE) {
      SVG_TYPE["line"] = "L";
      SVG_TYPE["curve"] = "Q";
      SVG_TYPE["none"] = "none";
  })(SVG_TYPE || (SVG_TYPE = {}));

  const createCache = () => {
      let CacheQueue = [];
      const EnterCache = (context) => {
          CacheQueue.pop();
          CacheQueue.unshift(context);
      };
      const OutCache = () => {
          CacheQueue.shift();
          CacheQueue.push(0);
      };
      const initCache = (cache) => {
          CacheQueue = new Array(cache).map(() => 0);
      };
      return {
          CacheQueue,
          initCache,
          EnterCache,
          OutCache,
      };
  };

  const useDragComponet = (com) => {
      let clickComponet = {};
      function setComponet(com) {
          clickComponet.com = com;
      }
      return {
          clickComponet,
          setComponet,
      };
  };

  const addEvent = (el, dw) => {
      el.el.style.cursor = "pointer";
      el.el.onclick = function () {
          if (dw.status == "none") {
              dw.activeComponet = el;
          }
      };
  };
  const montageOffset = (list, reduce = 1) => {
      function compute(data) {
          if (data == undefined) {
              return false;
          }
          if (reduce < -1) {
              return data / Math.abs(reduce);
          }
          else if (reduce > 1) {
              return data * reduce;
          }
          else {
              return data;
          }
      }
      return list.reduce((total, item) => {
          return (total +
              ` ${item.type} ${compute(item.x1) || ""} ${compute(item.y1) || ""} ${compute(item.x)} ${compute(item.y)}`);
      }, "");
  };
  const minPoint = (path) => {
      let obj = {};
      obj.x = path.reduce((min, item) => {
          return min > item.x ? item.x : min;
      }, path[0].x);
      obj.y = path.reduce((min, item) => {
          return min > item.y ? item.y : min;
      }, path[0].y);
      return obj;
  };
  const pointOffset = (point, offsetObj) => {
      return point.map((item) => {
          item.x = item.x - offsetObj.x;
          item.y = item.y - offsetObj.y;
          item.x1 = item.x1 - offsetObj.x;
          item.y1 = item.y1 - offsetObj.y;
          return item;
      });
  };
  const addDragEvent = (com) => {
      com.el.onmousedown = () => {
          setComponet(com);
      };
      com.el.onmouseup = () => {
          setComponet(null);
      };
  };
  const countPoint = (dw) => {
      const points = dw.idStore[dw.activeComponet.id].point;
      const arr = points.sort((a, b) => a.y - b.y);
      if (arr[1].y == arr[2].y) {
          let temp1 = arr[0];
          let temp2 = arr[1];
          let temp3 = arr[2];
          arr[0] = temp2.x > temp3.x ? temp3 : temp2;
          arr[1] = temp1;
          arr[2] = temp2.x > temp3.x ? temp2 : temp3;
      }
      else {
          if (arr[0].x >= arr[1].x) {
              let temp = arr[0];
              arr[0] = arr[1];
              arr[1] = temp;
          }
          if (arr[2].x <= arr[3].x) {
              let temp = arr[2];
              arr[2] = arr[3];
              arr[3] = temp;
          }
      }
      return arr;
  };
  function rectTopath(x, y, width, height, rx, ry) {
      /*
       * rx 和 ry 的规则是：
       * 1. 如果其中一个设置为 0 则圆角不生效
       * 2. 如果有一个没有设置则取值为另一个
       */
      rx = rx || ry || 0;
      ry = ry || rx || 0;
      //非数值单位计算，如当宽度像100%则移除
      if (isNaN(x - y + width - height + rx - ry))
          return;
      rx = rx > width / 2 ? width / 2 : rx;
      ry = ry > height / 2 ? height / 2 : ry;
      //如果其中一个设置为 0 则圆角不生效
      if (0 == rx || 0 == ry) {
          // var path =
          // 'M' + x + ' ' + y +
          // 'H' + (x + width) + 不推荐用绝对路径，相对路径节省代码量
          // 'V' + (y + height) +
          // 'H' + x +
          // 'z';
          var path = "M" + x + " " + y + "h" + width + "v" + height + "h" + -width + "z";
      }
      else {
          var path = "M" +
              x +
              " " +
              (y + ry) +
              " a " +
              rx +
              " " +
              ry +
              " 0 0 1 " +
              rx +
              " " +
              -ry +
              " h " +
              (width - rx - rx) +
              " a " +
              rx +
              " " +
              ry +
              " 0 0 1 " +
              rx +
              " " +
              ry +
              " v " +
              (height - ry - ry) +
              " a " +
              rx +
              " " +
              ry +
              " 0 0 1 " +
              -rx +
              " " +
              ry +
              " h " +
              (rx + rx - width) +
              " a " +
              rx +
              " " +
              ry +
              " 0 0 1 " +
              -rx +
              " " +
              -ry +
              " z";
      }
      return path;
  }
  function ellipseTopath(cx, cy, rx, ry) {
      //非数值单位计算，如当宽度像100%则移除
      if (isNaN(cx - cy + rx - ry))
          return;
      var path = "M" +
          (cx - rx) +
          " " +
          cy +
          "a" +
          rx +
          " " +
          ry +
          " 0 1 0 " +
          2 * rx +
          " 0" +
          "a" +
          rx +
          " " +
          ry +
          " 0 1 0 " +
          -2 * rx +
          " 0" +
          "z";
      return path;
  }

  const createSvgTag = () => {
      const Svg = document.createElementNS(DEFAULT_SVGNS, "svg");
      const Defs = document.createElementNS(DEFAULT_SVGNS, "defs");
      Defs.id = "defs";
      Svg.appendChild(Defs);
      return Svg;
  };

  const initCanvas = (parent, width, height, multiple, dw) => {
      const mSvg = createSvgTag();
      mSvg.setAttribute("style", `position: absolute;
    transform-origin: 0 0;
    width:${width * multiple}px;
    height:${height * multiple}px;
    user-select:none;
    left: 0;
    right: 0;
    background: #fbf8f8;`);
      parent.style.position = "relative";
      parent.style.overflow = "hidden";
      parent.style.width = width + "px";
      parent.style.height = height + "px";
      parent.style.border = "1px solid #ccc";
      parent.appendChild(mSvg);
      initDrag(mSvg, parent, dw);
      return mSvg;
  };
  function getContextOffset(mSvg, point) {
      return {
          x: point.x - mSvg.getBoundingClientRect().left,
          y: point.y - mSvg.getBoundingClientRect().top,
      };
  }
  function initDrag(mSvg, parent, dw) {
      let x;
      let y;
      let dx;
      let dy;
      let flag;
      let keyDown;
      let scale = 1;
      function moueScale(e) {
          if (e.wheelDelta > 0) {
              scale += 0.1;
          }
          else {
              scale = scale >= 0.6 ? scale - 0.1 : 0.5;
          }
          dw.scale = scale;
          mSvg.style.transform = `scale(${scale})`;
      }
      function up(event) {
          var _a;
          dw.isEdit = false;
          flag = false;
          setEditPoint(dw, (_a = dw.isDrawBypoint) === null || _a === void 0 ? void 0 : _a.type);
          dw.isDrawBypoint = null;
      }
      mSvg.addEventListener("mousewheel", moueScale);
      window.addEventListener("mouseup", up);
      mSvg.onmousedown = function (event) {
          dx = event.clientX;
          dy = event.clientY;
          if (dw.isEdit) {
              return;
          }
          dw.isDrag = true;
          x = event.offsetX * scale;
          y = event.offsetY * scale;
          flag = true;
          if (dw.isDrawBypoint) {
              dw.isDrawBypoint.startDrawPosition(getContextOffset(mSvg, {
                  x: event.clientX,
                  y: event.clientY,
              }));
          }
      };
      window.addEventListener("keydown", keydown);
      function keydown(event) {
          if (event.key == "Control" && !keyDown) {
              keyDown = true;
          }
      }
      window.addEventListener("keyup", keyup);
      function keyup(event) {
          if (event.key == "Control") {
              keyDown = false;
          }
      }
      mSvg.onmouseup = up;
      mSvg.onmousemove = function (event) {
          var _a;
          let offset = {
              x: (dx - event.clientX) / (dw === null || dw === void 0 ? void 0 : dw.scale),
              y: (dy - event.clientY) / (dw === null || dw === void 0 ? void 0 : dw.scale),
          };
          if (dw.isDrawBypoint &&
              !keyDown &&
              flag &&
              dw.isDrawBypoint.type == "rect" &&
              dw.isDrawBypoint.isEdit) {
              dw.isDrawBypoint.moveDrawPosition(-offset.x, -offset.y);
          }
          if (dw.isDrawBypoint &&
              !keyDown &&
              flag &&
              dw.isDrawBypoint.type == "ellipse" &&
              dw.isDrawBypoint.isEdit) {
              dw.isDrawBypoint.moveDrawPosition(-offset.x, -offset.y);
          }
          if (dw.isEdit && !keyDown && !dw.isDrawBypoint) {
              if (dw.idStore[dw.activeComponet.id] &&
                  ["curve", "point"].includes(dw.activeEidter.type)) {
                  resetPath(dw, offset);
                  dx = event.clientX;
                  dy = event.clientY;
              }
              if (dw.idStore[dw.activeComponet.id] && dw.activeEidter.type == "rect") {
                  resetRect(dw, offset);
                  dx = event.clientX;
                  dy = event.clientY;
              }
              if (dw.idStore[dw.activeComponet.id] &&
                  dw.activeEidter.type == "ellipse") {
                  resetEllipse(dw, offset);
                  dx = event.clientX;
                  dy = event.clientY;
              }
              return;
          }
          if (flag && keyDown && dw.status == "none") {
              mSvg.style.left =
                  event.clientX - parent.getBoundingClientRect().left - x + "px";
              mSvg.style.top =
                  event.clientY - parent.getBoundingClientRect().top - y + "px";
          }
          //
          if (!keyDown &&
              flag &&
              clickComponet.com &&
              activeComponet &&
              ((_a = clickComponet.com) === null || _a === void 0 ? void 0 : _a.id) === (activeComponet === null || activeComponet === void 0 ? void 0 : activeComponet.id)) {
              dw.isDrag = true;
              dw.idStore[clickComponet.com.id].point = pointOffset(dw.idStore[clickComponet.com.id].point, offset);
              if (clickComponet.com.type == "ellipse") {
                  clickComponet.com.setPoint(offset);
                  dx = event.clientX;
                  dy = event.clientY;
                  return;
              }
              if (clickComponet.com.type == "rect") {
                  clickComponet.com.setPoint(offset);
                  dx = event.clientX;
                  dy = event.clientY;
                  return;
              }
              clickComponet.com.setPoint(montageOffset(dw.idStore[clickComponet.com.id].point));
          }
          dx = event.clientX;
          dy = event.clientY;
      };
  }
  function resetPath(dw, offset) {
      const point = dw.idStore[dw.activeComponet.id].point;
      if (dw.activeEidter.type == "curve") {
          dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].x1 =
              dw.activeEidter.x - offset.x;
          dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].y1 =
              dw.activeEidter.y - offset.y;
      }
      if (dw.activeEidter.index !== point.length - 1) {
          if (dw.activeEidter.type == "point") {
              dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].x =
                  dw.activeEidter.x - offset.x;
              dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].y =
                  dw.activeEidter.y - offset.y;
          }
      }
      let eql = dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].x ==
          dw.idStore[dw.activeComponet.id].point[0].x &&
          dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].y ==
              dw.idStore[dw.activeComponet.id].point[0].y;
      if (dw.activeEidter.index == point.length - 1 &&
          eql &&
          dw.activeEidter.type == "point") {
          dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].x =
              dw.activeEidter.x - offset.x;
          dw.idStore[dw.activeComponet.id].point[dw.activeEidter.index].y =
              dw.activeEidter.y - offset.y;
          dw.idStore[dw.activeComponet.id].point[0].x = dw.activeEidter.x - offset.x;
          dw.idStore[dw.activeComponet.id].point[0].y = dw.activeEidter.y - offset.y;
      }
      dw.activeEidter.setPosition(dw.activeEidter.x - offset.x, dw.activeEidter.y - offset.y);
      dw.activeComponet.setPoint(montageOffset(dw.idStore[dw.activeComponet.id].point));
  }
  function resetEllipse(dw, offset) {
      dw._removePoint();
      dw._addPoint(dw.activeComponet);
      reSetPoint(dw);
      dw.activeComponet.setPoint(offset, dw.activeEidter.t);
      if (dw.activeEidter.t == "lt") {
          dw.activeComponet.moveDrawPosition(offset.x, 0);
      }
      else if (dw.activeEidter.t == "rt") {
          dw.activeComponet.moveDrawPosition(0, offset.y);
      }
      else if (dw.activeEidter.t == "rb") {
          dw.activeComponet.moveDrawPosition(-offset.x, 0);
      }
      else if (dw.activeEidter.t == "lb") {
          dw.activeComponet.moveDrawPosition(0, -offset.y);
      }
      dw.idStore[dw.activeComponet.id].point[0].x =
          dw.activeComponet.x + dw.activeComponet.width / 2;
      dw.idStore[dw.activeComponet.id].point[0].y = dw.activeComponet.y;
      dw.idStore[dw.activeComponet.id].point[1].x = dw.activeComponet.x;
      dw.idStore[dw.activeComponet.id].point[1].y =
          dw.activeComponet.y + dw.activeComponet.height / 2;
      dw.idStore[dw.activeComponet.id].point[2].x =
          dw.activeComponet.x + dw.activeComponet.width;
      dw.idStore[dw.activeComponet.id].point[2].y =
          dw.activeComponet.y + dw.activeComponet.height / 2;
      dw.idStore[dw.activeComponet.id].point[3].y =
          dw.activeComponet.y + dw.activeComponet.height;
      dw.idStore[dw.activeComponet.id].point[3].x = dw.activeComponet.x + dw.activeComponet.width / 2;
  }
  function resetRect(dw, offset) {
      dw._removePoint();
      dw._addPoint(dw.activeComponet);
      reSetPoint(dw);
      dw.activeComponet.setPoint(offset, dw.activeEidter.t);
      if (dw.activeEidter.t == "lt") {
          dw.activeComponet.moveDrawPosition(offset.x, offset.y);
      }
      else if (dw.activeEidter.t == "rt") {
          dw.activeComponet.moveDrawPosition(-offset.x, offset.y);
      }
      else if (dw.activeEidter.t == "rb") {
          dw.activeComponet.moveDrawPosition(-offset.x, -offset.y);
      }
      else if (dw.activeEidter.t == "lb") {
          dw.activeComponet.moveDrawPosition(offset.x, -offset.y);
      }
      dw.idStore[dw.activeComponet.id].point[0].x = dw.activeComponet.x;
      dw.idStore[dw.activeComponet.id].point[0].y = dw.activeComponet.y;
      dw.idStore[dw.activeComponet.id].point[1].x =
          dw.activeComponet.x + dw.activeComponet.width;
      dw.idStore[dw.activeComponet.id].point[1].y = dw.activeComponet.y;
      dw.idStore[dw.activeComponet.id].point[2].x =
          dw.activeComponet.x + dw.activeComponet.width;
      dw.idStore[dw.activeComponet.id].point[2].y =
          dw.activeComponet.y + dw.activeComponet.height;
      dw.idStore[dw.activeComponet.id].point[3].y =
          dw.activeComponet.y + dw.activeComponet.height;
      dw.idStore[dw.activeComponet.id].point[3].x = dw.activeComponet.x;
  }
  function reSetPoint(dw) {
      dw.idStore[dw.activeComponet.id].point = countPoint(dw);
      dw.idStore[dw.activeComponet.id].point[0].t = "lt";
      dw.idStore[dw.activeComponet.id].point[1].t = "rt";
      dw.idStore[dw.activeComponet.id].point[2].t = "rb";
      dw.idStore[dw.activeComponet.id].point[3].t = "lb";
      const currentEditer = dw.idStore[dw.activeComponet.id].point.findIndex((item) => item.id == dw.activeEidter.id);
      dw.activeEidter.t = dw.idStore[dw.activeComponet.id].point[currentEditer].t;
  }
  function setEditPoint(dw, type) {
      if (dw.isDrawBypoint && type == "rect") {
          dw.isDrawBypoint && (dw.isDrawBypoint.isEdit = false);
          dw.idStore[dw.isDrawBypoint.id].point = [
              { x: dw.isDrawBypoint.x, y: dw.isDrawBypoint.y, t: "lt", id: 1 },
              {
                  x: dw.isDrawBypoint.x + dw.isDrawBypoint.width,
                  y: dw.isDrawBypoint.y,
                  t: "rt",
                  id: 2,
              },
              {
                  x: dw.isDrawBypoint.x + dw.isDrawBypoint.width,
                  y: dw.isDrawBypoint.y + dw.isDrawBypoint.height,
                  t: "rb",
                  id: 3,
              },
              {
                  x: dw.isDrawBypoint.x,
                  y: dw.isDrawBypoint.y + dw.isDrawBypoint.height,
                  t: "lb",
                  id: 4,
              },
          ];
      }
      if (dw.isDrawBypoint && type == "ellipse") {
          dw.isDrawBypoint && (dw.isDrawBypoint.isEdit = false);
          dw.idStore[dw.isDrawBypoint.id].point = [
              {
                  x: dw.isDrawBypoint.x + dw.isDrawBypoint.width / 2,
                  y: dw.isDrawBypoint.y,
                  t: "lt",
                  id: 1,
              },
              {
                  x: dw.isDrawBypoint.x,
                  y: dw.isDrawBypoint.y + dw.isDrawBypoint.height / 2,
                  t: "rt",
                  id: 2,
              },
              {
                  x: dw.isDrawBypoint.x + dw.isDrawBypoint.width,
                  y: dw.isDrawBypoint.y + dw.isDrawBypoint.height / 2,
                  t: "rb",
                  id: 3,
              },
              {
                  x: dw.isDrawBypoint.x + dw.isDrawBypoint.width / 2,
                  y: dw.isDrawBypoint.y + dw.isDrawBypoint.height,
                  t: "lb",
                  id: 4,
              },
          ];
      }
  }

  class Circle {
      constructor(option, dw) {
          this.index = -1;
          this.flag = false;
          this.el = null;
          this.t = "";
          this.r = option.r || 2;
          this.lineColor = option.lineColor || "#000";
          this.lineWeight = option.lineWeight || 1;
          this.x = option.x || 0;
          this.y = option.y || 0;
          this.fill = option.fill || "transparent";
          this.el = document.createElementNS(DEFAULT_SVGNS, "circle");
          this.el.style.cursor = "n-resize";
          this.el.onmousedown = (event) => {
              dw.isEdit = true;
              dw.activeEidter = this;
          };
          this.el.onmouseup = (e) => {
              dw.isEdit = false;
          };
          this.draw("all");
      }
      draw(type) {
          if (type == "all" || type == "p") {
              this.el.setAttribute("cx", this.x);
              this.el.setAttribute("cy", this.y);
          }
          if (type == "all" || type == "t") {
              this.el.setAttribute("stroke", this.lineColor);
              this.el.setAttribute("stroke-width", this.lineWeight);
              this.el.setAttribute("fill", this.fill);
          }
          if (type == "all" || type == "r") {
              this.el.setAttribute("r", this.r);
          }
      }
      setPosition(x, y) {
          this.x = x;
          this.y = y;
          this.draw("p");
      }
      setTheme(theme) {
          this.lineColor = theme.color || this.lineColor;
          this.lineWeight = theme.weight || this.lineWeight;
          this.fill = theme.fill || this.fill;
          this.draw("t");
      }
      setR(r) {
          this.r = r;
          this.draw("r");
      }
  }

  const createVnode = function (list, dw) {
      console.log(list);
      return list;
  };
  const complairVnode = function (vnode, parent) {
      for (let index = 0; index < vnode.length; index++) {
          const element = vnode[index];
          let dom = document.createElementNS(DEFAULT_SVGNS, element.tagName);
          dom.attributes = element.attributes;
          dom.dataset = element.dataset;
          parent.appendChild(dom);
      }
  };

  class SvgComponet {
      constructor(option, dw) {
          this.x = 0;
          this.y = 0;
          this.el = null;
          this.lineColor = "#000";
          this.fill = "#000";
          this.lineWeight = 1;
          this.isVnodeComponet = true;
          this.activeColor = "";
          this.lineColor = option.lineColor || "#000";
          this.lineWeight = option.lineWeight || 1;
          this.fill = option.fill || "transparent";
          this.x = option.x || 0;
          this.y = option.y || 0;
      }
      startDrawPosition(position) {
          this.x = position.x;
          this.y = position.y;
      }
      draw(type) { }
      setTheme(theme) {
          this.lineColor = (theme === null || theme === void 0 ? void 0 : theme.color) || this.lineColor;
          this.lineWeight = (theme === null || theme === void 0 ? void 0 : theme.weight) || this.lineWeight;
          this.fill = (theme === null || theme === void 0 ? void 0 : theme.fill) || this.fill;
          this.draw("t");
      }
      setPosition(x, y) {
          this.x = x;
          this.y = y;
          this.draw("p");
      }
      setActive(color) {
          this.activeColor = color;
          this.el.setAttribute("stroke", color);
      }
      getPath() {
          return this.point;
      }
      motionByLine(list, options = {}) {
          this.x = 0;
          this.y = 0;
          this.draw("p");
          this.el.innerHTML = `<animateMotion dur="${options.dur || 5}s" repeatCount="${options.repeatCount || "indefinite"}" path="${list.getPath()}"></animateMotion>`;
          if (this.img) {
              this.img.innerHTML = `<animateMotion dur="${options.dur || 5}s" repeatCount="${options.repeatCount || "indefinite"}" path="${list.getPath()}"></animateMotion>`;
          }
      }
  }

  class Ellipse extends SvgComponet {
      constructor(option, dw) {
          super(option, dw);
          this.type = "ellipse";
          this.width = 0;
          this.height = 0;
          this.isEdit = false;
          this.point = "";
          this.options = {};
          this.el = document.createElementNS(DEFAULT_SVGNS, "ellipse");
          dw.isDrawBypoint = this;
          this.id = "r" + Date.now();
          this.el.setAttribute("id", this.id);
          this.draw("all");
      }
      moveDrawPosition(width, height) {
          this.width += width;
          this.height += height;
          this.draw("p");
          this.draw("r");
      }
      startDrawPosition(position) {
          this.x = position.x;
          this.y = position.y;
          this.draw("p");
      }
      setPoint(offset, t) {
          if (t == "rt") {
              this.y -= offset.y;
          }
          else if (t == "rb") ;
          else if (t == "lb") {
              this.x -= offset.x;
          }
          else {
              this.x -= offset.x;
              this.y -= offset.y;
          }
          this.draw("p");
      }
      setActive(color) {
          this.activeColor = color;
          this.el.style.stroke = color;
      }
      draw(type) {
          if (type == "all" || type == "p") {
              this.el.setAttribute("cx", this.x + this.width / 2);
              this.el.setAttribute("cy", this.y + this.height / 2);
          }
          if (type == "all" || type == "r") {
              this.el.setAttribute("rx", this.width / 2 > 0 ? this.width / 2 : 0);
              this.el.setAttribute("ry", this.height / 2 > 0 ? this.height / 2 : 0);
          }
          if (type == "all" || type == "t") {
              this.el.style.stroke = this.lineColor;
              this.el.style.strokeWidth = this.lineWeight;
              this.el.style.fill = this.fill;
          }
      }
      getPath() {
          return ellipseTopath(Number(this.el.getAttribute('cx')), Number(this.el.getAttribute('cy')), Number(this.el.getAttribute('rx')), Number(this.el.getAttribute('ry')));
      }
  }

  const createPath = (lineColor, lineWeight, fill) => {
      const path = document.createElementNS(DEFAULT_SVGNS, "path");
      path.setAttribute("stroke", lineColor);
      path.setAttribute("stroke-width", lineWeight);
      path.setAttribute("fill", fill);
      path.onmousedown = () => {
      };
      return path;
  };

  class Path extends SvgComponet {
      constructor(lineStyle, dw) {
          super(lineStyle, dw);
          this.el = null;
          this.id = "";
          this.dataset = {};
          this.point = "";
          this.type = "";
          this.options = {};
          this.el = createPath(lineStyle.lineColor || "#000", lineStyle.lineWeight || "1", lineStyle.fill ? lineStyle.fill : "transparent");
          this.id = "l" + Date.now();
          this.el.setAttribute("id", this.id);
          this.draw("all");
      }
      setPoint(point) {
          this.point = point;
          this.draw("p");
      }
      draw(type) {
          if (type == "all" || type == "p") {
              this.el.setAttribute("d", this.point);
          }
          if (type == "all" || type == "t") {
              this.el.setAttribute("stroke", this.lineColor);
              this.el.setAttribute("stroke-width", this.lineWeight);
              this.el.setAttribute("fill", this.fill);
          }
      }
  }

  class Rect extends SvgComponet {
      constructor(option, dw) {
          super(option, dw);
          this.width = 0;
          this.height = 0;
          this.ry = 0;
          this.rx = 0;
          this.isEdit = false;
          this.options = {};
          this.type = "rect";
          this.rx = option.rx || 0;
          this.ry = option.ry || 0;
          this.el = document.createElementNS(DEFAULT_SVGNS, "rect");
          dw.isDrawBypoint = this;
          this.dw = dw;
          this.id = "r" + Date.now();
          this.el.setAttribute("id", this.id);
          this.draw("all");
      }
      setRadius(rx, ry) {
          this.rx = rx;
          this.ry = ry;
          this.draw("ra");
      }
      setImage(url, ratio = "none") {
          var _a;
          this.img = document.createElementNS(DEFAULT_SVGNS, "image");
          this.img.setAttribute("href", url);
          this.img.onmousedown = () => {
              setComponet(this);
          };
          this.img.onmouseup = () => {
              setComponet(null);
          };
          this.img.style.cursor = "pointer";
          this.img.onclick = () => {
              if (this.dw.status == "none") {
                  this.dw.activeComponet = this;
              }
          };
          this.img.setAttribute("preserveAspectRatio", ratio);
          (_a = this.dw.canvas) === null || _a === void 0 ? void 0 : _a.appendChild(this.img);
          this.draw("all");
      }
      moveDrawPosition(width, height) {
          this.width += width;
          this.height += height;
          this.draw("c");
          this.draw("t");
      }
      startDrawPosition(position) {
          this.x = position.x;
          this.y = position.y;
          this.draw("p");
      }
      setPoint(offset, t) {
          if (t == "rt") {
              this.y -= offset.y;
          }
          else if (t == "rb") ;
          else if (t == "lb") {
              this.x -= offset.x;
          }
          else {
              this.x -= offset.x;
              this.y -= offset.y;
          }
          this.draw("p");
      }
      setActive(color) {
          this.activeColor = color;
          this.el.style.stroke = color;
      }
      draw(type) {
          var _a, _b, _c, _d;
          if (type == "all" || type == "p") {
              this.el.setAttribute("x", this.x);
              this.el.setAttribute("y", this.y);
              (_a = this.img) === null || _a === void 0 ? void 0 : _a.setAttribute("x", this.x);
              (_b = this.img) === null || _b === void 0 ? void 0 : _b.setAttribute("y", this.y);
          }
          if (type == "all" || type == "ra") {
              this.el.setAttribute("rx", this.rx);
              this.el.setAttribute("ry", this.ry);
          }
          if (type == "all" || type == "t") {
              this.el.style.stroke = this.lineColor;
              this.el.style.strokeWidth = this.lineWeight;
              this.el.style.fill = this.fill;
          }
          if (type == "all" || type == "c") {
              this.el.setAttribute("width", this.width > 0 ? this.width : 0);
              this.el.setAttribute("height", this.height > 0 ? this.height : 0);
              (_c = this.img) === null || _c === void 0 ? void 0 : _c.setAttribute("width", this.width > 0 ? this.width : 0);
              (_d = this.img) === null || _d === void 0 ? void 0 : _d.setAttribute("height", this.height > 0 ? this.height : 0);
          }
      }
      getPath() {
          return rectTopath(Number(this.el.getAttribute("x")), Number(this.el.getAttribute("y")), Number(this.el.getAttribute("width")), Number(this.el.getAttribute("height")), Number(this.el.getAttribute("rx")), Number(this.el.getAttribute("ry")));
      }
  }

  let activeComponet = null;
  const { CacheQueue, initCache, EnterCache, OutCache } = createCache();
  let { setComponet, clickComponet } = useDragComponet();
  class Drawer {
      get isDrag() {
          return this._isDrag;
      }
      set isDrag(val) {
          this._isDrag = val;
          if (val) {
              this._removePoint();
          }
          else {
              this._addPoint(this.activeComponet);
          }
      }
      get activeComponet() {
          return this._ActiveComponet;
      }
      set activeComponet(val) {
          var _a;
          if (typeof val !== "string") {
              const isSelect = !!this.children.find((item) => item.id === val.id);
              if (isSelect) {
                  if (this._ActiveComponet) {
                      this._ActiveComponet.setTheme();
                  }
                  this._ActiveComponet.activeColor = this._ActiveComponet.lineColor;
                  this._ActiveComponet = val;
                  val.setActive(this.activeColor);
                  activeComponet = val;
              }
              if (!isSelect) {
                  this._ActiveComponet = val;
              }
              this._addPoint(val);
          }
          else {
              this._removePoint();
              (_a = this._ActiveComponet) === null || _a === void 0 ? void 0 : _a.setTheme({ color: val });
              this._ActiveComponet.activeColor = val;
          }
      }
      constructor(el, option) {
          this.scale = 1;
          this.isEdit = false;
          this.dev = true;
          this.extremePoints = [];
          this.children = [];
          this.pointList = [];
          this.idStore = {};
          this._isDrag = false;
          this.activeColor = "rgb(43,219,237)";
          if (!el || typeof el !== "object" || !el.tagName) {
              throw new Error("You need to pass in a HTMLElement");
          }
          this.width = (option === null || option === void 0 ? void 0 : option.width) || DEFAULT_SIZE;
          this.height = (option === null || option === void 0 ? void 0 : option.height) || DEFAULT_SIZE;
          this.cache = (option === null || option === void 0 ? void 0 : option.cache) || DEFAULT_CACHE;
          this.multiple = (option === null || option === void 0 ? void 0 : option.multiple) || DEFAULT_MULTIPLE;
          this._DOM = el;
          this.status = "none";
          this.init();
          initCache(this.cache);
      }
      init() {
          this.canvas = initCanvas(this._DOM, this.width, this.height, this.multiple, this);
          this.group = document.getElementById("defs");
          this.canvas.onclick = (e) => {
              var _a;
              if (this.status == "line") {
                  let point = this.activeComponet.point;
                  let obj = {
                      x: e.offsetX,
                      y: e.offsetY,
                  };
                  if (point) {
                      point += ` ${SVG_PATH_DIRECTION.L} ${e.offsetX} ${e.offsetY}`;
                      obj.type = SVG_PATH_DIRECTION.L;
                  }
                  else {
                      point = `${SVG_PATH_DIRECTION.M} ${e.offsetX} ${e.offsetY}`;
                      obj.type = SVG_PATH_DIRECTION.M;
                  }
                  this.idStore[this.activeComponet.id].point.push(obj);
                  this.activeComponet.setPoint(point);
              }
              if (this.status == "curve") {
                  let point = this.activeComponet.point;
                  let obj = {
                      x: e.offsetX,
                      y: e.offsetY,
                  };
                  if (point) {
                      const oi = this.idStore[this.activeComponet.id].point[this.idStore[this.activeComponet.id].point.length - 1];
                      let x = oi.x;
                      let y = oi.y;
                      obj.x1 = (e.offsetX - x) / 2 + x;
                      obj.y1 = (e.offsetY - y) / 2 + y;
                      point += ` ${SVG_PATH_DIRECTION.Q} ${obj.x1} ${obj.y1} ${e.offsetX} ${e.offsetY}`;
                      obj.type = SVG_PATH_DIRECTION.Q;
                  }
                  else {
                      point = `${SVG_PATH_DIRECTION.M} ${e.offsetX} ${e.offsetY}`;
                      obj.type = SVG_PATH_DIRECTION.M;
                  }
                  this.idStore[this.activeComponet.id].point.push(obj);
                  this.activeComponet.setPoint(point);
              }
              let target = e.target;
              if ((target === null || target === void 0 ? void 0 : target.nodeName) == "svg" && this.status == "none") {
                  this.activeComponet = ((_a = this._ActiveComponet) === null || _a === void 0 ? void 0 : _a.lineColor) || "#000";
              }
          };
      }
      clearLast() {
          if (this._ActiveComponet) {
              this._ActiveComponet.setTheme();
          }
      }
      reStart(path) {
          const com = path || this.activeComponet;
          if (!com) {
              return;
          }
          com.setAttribute("stroke", this.activeColor);
          this.status = com.type;
          return () => {
              this.status = "none";
              this._closeFn();
              this.activeComponet = this.activeComponet.line;
          };
      }
      getCanvasContext() {
          return createVnode(this.children);
      }
      setCanvasContext(vnode) {
          var _a;
          let g = document.createElementNS(DEFAULT_SVGNS, "g");
          let id = "" + Date.now();
          g.id = id;
          complairVnode(vnode, g);
          (_a = this.group) === null || _a === void 0 ? void 0 : _a.appendChild(g);
          // return complairVnode(vnode, g);
      }
      _addPoint(path) {
          var _a, _b, _c;
          const id = path.id;
          if (this.idStore[id] && this.idStore[id].point.length) {
              let point = this.idStore[id].point;
              this._removePoint();
              if (["curve", "line"].includes(path.type)) {
                  let eql = point[0].x == point[point.length - 1].x &&
                      point[0].y == point[point.length - 1].y;
                  for (let index = 0; index < point.length; index++) {
                      const element = point[index];
                      let circle = new Circle({
                          r: 4,
                          x: element.x,
                          y: element.y,
                          fill: this.activeColor,
                          edit: true,
                      }, this);
                      let circle1;
                      if (element.x1 && element.y1) {
                          circle1 = new Circle({
                              r: 4,
                              x: element.x1,
                              y: element.y1,
                              fill: this.activeColor,
                              edit: true,
                          }, this);
                          circle1.index = index;
                          circle1.type = "curve";
                          (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.appendChild(circle1.el);
                          this.pointList.push({
                              type: "curve",
                              el: circle1.el,
                          });
                      }
                      if (!eql || index != 0) {
                          circle.type = "point";
                          circle.index = index;
                          (_b = this.canvas) === null || _b === void 0 ? void 0 : _b.appendChild(circle.el);
                          this.pointList.push({
                              type: "point",
                              el: circle.el,
                          });
                      }
                  }
              }
              if (["rect", "ellipse"].includes(path.type)) {
                  for (let index = 0; index < point.length; index++) {
                      const element = point[index];
                      let circle = new Circle({
                          r: 4,
                          x: element.x,
                          y: element.y,
                          fill: this.activeColor,
                          edit: true,
                      }, this);
                      circle.id = element.id ? element.id : index + 1;
                      circle.t = element.t;
                      circle.type = path.type;
                      (_c = this.canvas) === null || _c === void 0 ? void 0 : _c.appendChild(circle.el);
                      this.pointList[index] = circle;
                  }
              }
          }
      }
      _removePoint() {
          if (this.pointList && this.pointList.length) {
              this.pointList.map((item) => {
                  var _a;
                  (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.removeChild(item.el);
              });
          }
          this.pointList = [];
      }
      setBlank(offsetIn) {
          if (offsetIn && (!offsetIn.x || !offsetIn.y)) {
              throw new Error("offset need x and y");
          }
          this._filterData();
          let arr = [];
          for (const key in this.idStore) {
              arr.push(minPoint(this.idStore[key].point));
          }
          const offset = offsetIn || minPoint(arr);
          this.children.map((item) => {
              const point = this.idStore[item.id].point;
              const point2 = pointOffset(point, offset);
              item.setPoint(montageOffset(point2));
          });
      }
      _filterData() {
          this.children = this.children.filter((item) => {
              var _a, _b, _c;
              if (!this.idStore[item.id].point.length) {
                  (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.removeChild(item.el);
                  delete this.idStore[item.id];
              }
              return (_c = (_b = this.idStore[item.id]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.length;
          });
      }
      _closeFn() {
          if (this.idStore[this.activeComponet.id].lineStyle.autoClose &&
              this.idStore[this.activeComponet.id].point[0]) {
              const oi = this.idStore[this.activeComponet.id].point[this.idStore[this.activeComponet.id].point.length - 1];
              let point = this.idStore[this.activeComponet.id].point;
              let x1 = (point[0].x - oi.x) / 2 + oi.x;
              let y1 = (point[0].y - oi.y) / 2 + oi.y;
              this.idStore[this.activeComponet.id].point.push(Object.assign({ type: SVG_TYPE[this.status], x: point[0].x, y: point[0].y }, (this.status == "curve" ? { x1, y1 } : {})));
              this.activeComponet.setPoint(montageOffset(this.idStore[this.activeComponet.id].point));
          }
          this._filterData();
          this.activeComponet = this.activeComponet.lineColor || "#000";
      }
      drawLine(lineStyle = {}) {
          var _a;
          if (this.status == "line") {
              this._closeFn();
          }
          this.status = "line";
          this.clearLast();
          this._removePoint();
          const path = new Path(lineStyle, this);
          path.options = lineStyle;
          path.type = "line";
          this.activeComponet = path;
          this.idStore[path.id] = {
              type: "line",
              lineStyle: lineStyle,
              point: [],
          };
          addEvent(path, this);
          addDragEvent(path);
          this.children.push(path);
          (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.appendChild(path.el);
          return () => {
              this._closeFn();
              this.activeComponet = path.lineColor;
              this.status = "none";
              return path;
          };
      }
      drawRect(lineStyle = {}) {
          var _a;
          const rect = new Rect(lineStyle, this);
          rect.options = lineStyle;
          rect.type = "rect";
          rect.isEdit = true;
          this.activeComponet = rect;
          this.idStore[rect.id] = {
              type: "rect",
              lineStyle: lineStyle,
              point: [],
          };
          addEvent(rect, this);
          addDragEvent(rect);
          this.children.push(rect);
          (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.appendChild(rect.el);
          return rect;
      }
      drawEllipse(lineStyle = {}) {
          var _a;
          const ellipse = new Ellipse(lineStyle, this);
          ellipse.options = lineStyle;
          ellipse.type = "ellipse";
          ellipse.isEdit = true;
          this.activeComponet = ellipse;
          this.idStore[ellipse.id] = {
              type: "ellipse",
              lineStyle: lineStyle,
              point: [],
          };
          addEvent(ellipse, this);
          addDragEvent(ellipse);
          this.children.push(ellipse);
          (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.appendChild(ellipse.el);
          return ellipse;
      }
      drawCurve(lineStyle = {}) {
          var _a;
          if (this.status == "curve") {
              this._closeFn();
          }
          this.status = "curve";
          this.clearLast();
          this._removePoint();
          const path = new Path(lineStyle, this);
          path.options = lineStyle;
          path.type = "curve";
          this.activeComponet = path;
          this.idStore[path.id] = {
              type: "curve",
              lineStyle: lineStyle,
              point: [],
          };
          addEvent(path, this);
          addDragEvent(path);
          this.children.push(path);
          (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.appendChild(path.el);
          return () => {
              this._closeFn();
              this.activeComponet = path.lineColor;
              this.status = "none";
              return path;
          };
      }
  }

  if (window) {
      window.Drawer = Drawer;
  }

  exports.Drawer = Drawer;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
